//
//  IkepodMinuteHand.swift
//  MyClock
//
//  Created by sb on 13-A-21.
//  Copyright Â© 2021 tukgaesoft. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class ClockHands : NSObject {

    //// Drawing Methods

    @objc dynamic public class func drawCanvas1(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 125, height: 120), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 125, height: 120), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 125, y: resizedFrame.height / 120)


        //// Color Declarations
        let color = UIColor(red: 0.750, green: 0.376, blue: 0.002, alpha: 1.000)
        let color2 = UIColor(red: 1.000, green: 0.500, blue: 0.000, alpha: 1.000)
        let color3 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// SecondHand
        //// Bezier 4 Drawing
        static var SecondHand: UIBezierPath {
            bezier4Path.move(to: CGPoint(x: 27.14, y: 89.47))
            bezier4Path.addCurve(to: CGPoint(x: 23.14, y: 93.47), controlPoint1: CGPoint(x: 24.93, y: 89.47), controlPoint2: CGPoint(x: 23.14, y: 91.26))
            bezier4Path.addCurve(to: CGPoint(x: 27.14, y: 97.47), controlPoint1: CGPoint(x: 23.14, y: 95.68), controlPoint2: CGPoint(x: 24.93, y: 97.47))
            bezier4Path.addCurve(to: CGPoint(x: 31.14, y: 93.47), controlPoint1: CGPoint(x: 29.35, y: 97.47), controlPoint2: CGPoint(x: 31.14, y: 95.68))
            bezier4Path.addCurve(to: CGPoint(x: 30.92, y: 92.17), controlPoint1: CGPoint(x: 31.14, y: 93.02), controlPoint2: CGPoint(x: 31.06, y: 92.58))
            bezier4Path.addCurve(to: CGPoint(x: 27.14, y: 89.47), controlPoint1: CGPoint(x: 30.38, y: 90.6), controlPoint2: CGPoint(x: 28.89, y: 89.47))
            bezier4Path.close()
            bezier4Path.move(to: CGPoint(x: 28.89, y: 17.55))
            bezier4Path.addCurve(to: CGPoint(x: 30.64, y: 62.9), controlPoint1: CGPoint(x: 28.89, y: 18.09), controlPoint2: CGPoint(x: 29.31, y: 45.97))
            bezier4Path.addCurve(to: CGPoint(x: 34.14, y: 93.24), controlPoint1: CGPoint(x: 31.8, y: 77.77), controlPoint2: CGPoint(x: 34.14, y: 91.21))
            bezier4Path.addCurve(to: CGPoint(x: 27.14, y: 100.32), controlPoint1: CGPoint(x: 34.14, y: 97.56), controlPoint2: CGPoint(x: 30.64, y: 100.32))
            bezier4Path.addCurve(to: CGPoint(x: 20.14, y: 93.24), controlPoint1: CGPoint(x: 23.64, y: 100.32), controlPoint2: CGPoint(x: 20.14, y: 97.56))
            bezier4Path.addCurve(to: CGPoint(x: 23.64, y: 62.9), controlPoint1: CGPoint(x: 20.14, y: 91.21), controlPoint2: CGPoint(x: 22.47, y: 77.76))
            bezier4Path.addCurve(to: CGPoint(x: 25.39, y: 17.55), controlPoint1: CGPoint(x: 24.96, y: 45.96), controlPoint2: CGPoint(x: 25.39, y: 18.09))
            bezier4Path.addCurve(to: CGPoint(x: 26.96, y: 15.38), controlPoint1: CGPoint(x: 25.39, y: 16.6), controlPoint2: CGPoint(x: 26.05, y: 15.51))
            bezier4Path.addCurve(to: CGPoint(x: 27.14, y: 15.37), controlPoint1: CGPoint(x: 27.02, y: 15.38), controlPoint2: CGPoint(x: 27.08, y: 15.37))
            bezier4Path.addCurve(to: CGPoint(x: 28.89, y: 17.55), controlPoint1: CGPoint(x: 28.14, y: 15.37), controlPoint2: CGPoint(x: 28.89, y: 16.54))
            bezier4Path.close()
            color2.setFill()
            bezier4Path.fill()
            return bezier4Path
        }

        //// MinuteHand
        //// Bezier 3 Drawing
        static var MinuteHand: UIBezierPath {
            bezier3Path.move(to: CGPoint(x: 61.14, y: 89.47))
            bezier3Path.addCurve(to: CGPoint(x: 57.14, y: 93.47), controlPoint1: CGPoint(x: 58.93, y: 89.47), controlPoint2: CGPoint(x: 57.14, y: 91.26))
            bezier3Path.addCurve(to: CGPoint(x: 61.14, y: 97.47), controlPoint1: CGPoint(x: 57.14, y: 95.68), controlPoint2: CGPoint(x: 58.93, y: 97.47))
            bezier3Path.addCurve(to: CGPoint(x: 65.14, y: 93.47), controlPoint1: CGPoint(x: 63.35, y: 97.47), controlPoint2: CGPoint(x: 65.14, y: 95.68))
            bezier3Path.addCurve(to: CGPoint(x: 64.87, y: 92.02), controlPoint1: CGPoint(x: 65.14, y: 92.96), controlPoint2: CGPoint(x: 65.04, y: 92.47))
            bezier3Path.addCurve(to: CGPoint(x: 61.14, y: 89.47), controlPoint1: CGPoint(x: 64.28, y: 90.53), controlPoint2: CGPoint(x: 62.83, y: 89.47))
            bezier3Path.close()
            bezier3Path.move(to: CGPoint(x: 63.14, y: 27.5))
            bezier3Path.addCurve(to: CGPoint(x: 65.14, y: 62.9), controlPoint1: CGPoint(x: 63.14, y: 28.04), controlPoint2: CGPoint(x: 63.81, y: 45.97))
            bezier3Path.addCurve(to: CGPoint(x: 68.14, y: 93.24), controlPoint1: CGPoint(x: 66.3, y: 77.77), controlPoint2: CGPoint(x: 68.14, y: 91.21))
            bezier3Path.addCurve(to: CGPoint(x: 61.14, y: 100.32), controlPoint1: CGPoint(x: 68.14, y: 97.56), controlPoint2: CGPoint(x: 64.64, y: 100.32))
            bezier3Path.addCurve(to: CGPoint(x: 54.14, y: 93.24), controlPoint1: CGPoint(x: 57.64, y: 100.32), controlPoint2: CGPoint(x: 54.14, y: 97.56))
            bezier3Path.addCurve(to: CGPoint(x: 57.14, y: 62.9), controlPoint1: CGPoint(x: 54.14, y: 91.21), controlPoint2: CGPoint(x: 55.97, y: 77.76))
            bezier3Path.addCurve(to: CGPoint(x: 59.14, y: 27.5), controlPoint1: CGPoint(x: 58.46, y: 45.96), controlPoint2: CGPoint(x: 59.14, y: 28.04))
            bezier3Path.addCurve(to: CGPoint(x: 60.96, y: 25.33), controlPoint1: CGPoint(x: 59.14, y: 26.55), controlPoint2: CGPoint(x: 60.02, y: 25.46))
            bezier3Path.addCurve(to: CGPoint(x: 61.14, y: 25.32), controlPoint1: CGPoint(x: 61.02, y: 25.32), controlPoint2: CGPoint(x: 61.08, y: 25.32))
            bezier3Path.addCurve(to: CGPoint(x: 63.14, y: 27.5), controlPoint1: CGPoint(x: 62.14, y: 25.32), controlPoint2: CGPoint(x: 63.14, y: 26.49))
            bezier3Path.close()
            color2.setFill()
            bezier3Path.fill()
            color.setStroke()
            bezier3Path.lineWidth = 1
            bezier3Path.stroke()
            return bezier3Path
        }

        //// HourHand
        //// Bezier Drawing
        static var hourHand: UIBezierPath {
            bezierPath.move(to: CGPoint(x: 97, y: 89.47))
            bezierPath.addCurve(to: CGPoint(x: 93, y: 93.47), controlPoint1: CGPoint(x: 94.79, y: 89.47), controlPoint2: CGPoint(x: 93, y: 91.26))
            bezierPath.addCurve(to: CGPoint(x: 97, y: 97.47), controlPoint1: CGPoint(x: 93, y: 95.68), controlPoint2: CGPoint(x: 94.79, y: 97.47))
            bezierPath.addCurve(to: CGPoint(x: 101, y: 93.47), controlPoint1: CGPoint(x: 99.21, y: 97.47), controlPoint2: CGPoint(x: 101, y: 95.68))
            bezierPath.addCurve(to: CGPoint(x: 100.59, y: 91.71), controlPoint1: CGPoint(x: 101, y: 92.84), controlPoint2: CGPoint(x: 100.85, y: 92.24))
            bezierPath.addCurve(to: CGPoint(x: 97, y: 89.47), controlPoint1: CGPoint(x: 99.94, y: 90.38), controlPoint2: CGPoint(x: 98.57, y: 89.47))
            bezierPath.close()
            bezierPath.move(to: CGPoint(x: 99.15, y: 51.11))
            bezierPath.addCurve(to: CGPoint(x: 101, y: 70.91), controlPoint1: CGPoint(x: 99.15, y: 51.65), controlPoint2: CGPoint(x: 99.67, y: 53.99))
            bezierPath.addCurve(to: CGPoint(x: 104, y: 93.24), controlPoint1: CGPoint(x: 102.16, y: 85.79), controlPoint2: CGPoint(x: 104, y: 91.21))
            bezierPath.addCurve(to: CGPoint(x: 97, y: 100.32), controlPoint1: CGPoint(x: 104, y: 97.56), controlPoint2: CGPoint(x: 100.5, y: 100.32))
            bezierPath.addCurve(to: CGPoint(x: 90, y: 93.24), controlPoint1: CGPoint(x: 93.5, y: 100.32), controlPoint2: CGPoint(x: 90, y: 97.56))
            bezierPath.addCurve(to: CGPoint(x: 93, y: 70.93), controlPoint1: CGPoint(x: 90, y: 91.21), controlPoint2: CGPoint(x: 91.84, y: 85.79))
            bezierPath.addCurve(to: CGPoint(x: 94.85, y: 51.11), controlPoint1: CGPoint(x: 94.33, y: 54), controlPoint2: CGPoint(x: 94.85, y: 51.65))
            bezierPath.addCurve(to: CGPoint(x: 97, y: 48.99), controlPoint1: CGPoint(x: 94.85, y: 50.16), controlPoint2: CGPoint(x: 95.47, y: 48.99))
            bezierPath.addCurve(to: CGPoint(x: 99.15, y: 51.11), controlPoint1: CGPoint(x: 98, y: 48.99), controlPoint2: CGPoint(x: 99.15, y: 50.1))
            bezierPath.close()
            color3.setFill()
            bezierPath.fill()
            color2.setStroke()
            bezierPath.lineWidth = 1
            bezierPath.stroke()
            
            return bezierPath
        }
        
        context.restoreGState()


    }




    @objc(IkepodMinuteHandResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
